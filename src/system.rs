use serde::{Deserialize, Serialize};

use crate::{
    distributions::{ConsumingDistribution, ProducingDistribution},
    node::Node,
    queue::Queue,
    request::Request,
};

///! Yields new [`Request`]s for the [`System`] depending on the current tick
///! and distributions.
#[derive(Debug)]
pub(crate) struct Producer {
    ///! λ parameter for exponential distribution of the [`Request`]s.
    ///! producing.
    request_producing_dstr: ProducingDistribution,

    ///! Next tick when the new [`Request`] will be produced.
    ticks_to_next_request: u64,

    ///! The strategy with which will be defined how the time for processing the
    ///! [`Request`] will be generated.
    requests_consuming_dstr: ConsumingDistribution,

    ///! Identifier of last request. This is used to generate unique request
    ///! identifiers.
    last_request_id: u64,
}

impl Default for Producer {
    fn default() -> Self {
        Self {
            request_producing_dstr: ProducingDistribution::Exponential { λ: 0.0 },
            requests_consuming_dstr: ConsumingDistribution::Degenerate { μ: 1.0 },
            ticks_to_next_request: Default::default(),
            last_request_id: Default::default(),
        }
    }
}

impl Producer {
    ///! Create new [`Producer`] with from given producing and consuming distributions.
    pub(crate) fn new(prod_dsrt: ProducingDistribution, cons_dstr: ConsumingDistribution) -> Self {
        Self {
            ticks_to_next_request: 0,
            request_producing_dstr: prod_dsrt,
            requests_consuming_dstr: cons_dstr,
            last_request_id: 0,
        }
    }

    ///! Increment current tick of the [`Producer`] and return `true` if the new
    ///! [`Request`] should be produced.
    pub(crate) fn tick(&mut self) -> bool {
        if self.ticks_to_next_request == 0 {
            self.ticks_to_next_request =
                self.request_producing_dstr.sample(&mut rand::thread_rng()) as u64;
            true
        } else {
            self.ticks_to_next_request -= 1;
            false
        }
    }

    ///! Produce new [`Request`] with the time for processing generated by the
    ///! [`ConsumingDistribution`]
    pub(crate) fn produce(&mut self) -> Request {
        let ticks_to_consume = self.requests_consuming_dstr.sample(&mut rand::thread_rng());
        self.last_request_id += 1;

        Request::new(self.last_request_id, ticks_to_consume as u64)
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SystemState {
    pub current_tick: u64,
    pub nodes: Vec<Node>,
    pub queue: Queue,
}

impl SystemState {
    pub(crate) fn new(nodes_number: usize, queue_capacity: usize) -> Self {
        Self {
            current_tick: 0,
            queue: Queue::with_capacity(queue_capacity),
            nodes: {
                let mut nodes = Vec::with_capacity(nodes_number);
                for _ in 0..nodes_number {
                    nodes.push(Node::new());
                }
                nodes
            },
        }
    }
}

///! Model that represents all the system including [`Node`]s and queue
#[derive(Debug)]
pub struct System {
    state: SystemState,
    producer: Producer,
}

impl System {
    pub fn new(
        nodes_number: usize,
        queue_capacity: usize,
        consumer_dstr: ConsumingDistribution,
        producer_dsrt: ProducingDistribution,
    ) -> Self {
        Self {
            state: SystemState::new(nodes_number, queue_capacity),
            producer: Producer::new(producer_dsrt, consumer_dstr),
        }
    }

    ///! Increment current tick of the [`System`]
    pub fn tick<'a>(&'a mut self) -> SystemState {
        self.state.current_tick += 1;

        self.state.queue.tick();

        if self.producer.tick() && self.state.queue.has_space() {
            let request = self.producer.produce();
            self.state.queue.push(request);
        }

        for node in self.state.nodes.iter_mut() {
            if !node.tick() {
                continue;
            }
            if let Some(request) = self.state.queue.pop() {
                node.consume(request);
            }
        }

        self.state.clone()
    }
}
